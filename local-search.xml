<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C语言基础</title>
    <link href="/2024/01/28/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/01/28/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言基础"><a href="#C语言基础" class="headerlink" title="C语言基础"></a>C语言基础</h1><h2 id="0-变量命名"><a href="#0-变量命名" class="headerlink" title="0. 变量命名"></a>0. 变量命名</h2><p>C语言变量命名规则</p><ol><li><p>以字母或者下划线开始</p></li><li><p>由数字 字母 下划线组成</p></li><li><p>不能与C语言关键字相冲突</p><p><strong>附.<a href="./C%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97.md">C语言32个关键字</a></strong></p></li></ol><p>变量命名的原则</p><ul><li>见名知意</li></ul><hr><h2 id="1-C语言基本数据类型"><a href="#1-C语言基本数据类型" class="headerlink" title="1. C语言基本数据类型"></a>1. C语言基本数据类型</h2><p><strong>计算机内存</strong></p><ul><li>一个字节(bytes) &#x3D; 8位(bits) <code>无符号</code>：<strong>0~255</strong> <code>有符号</code>：**-128~127。**</li><li>一个字节表示的数的最小值：0000 0000 for 0  means 0。</li><li>一个字节表示的数的最大值：1111 1111 for 255 means 2 ^ 8 - 1。</li><li>两个字节(bytes) &#x3D; 16位(bits) <code>无符号</code>：<strong>0-65535</strong> <code>有符号</code> ：**-32768~32767。**</li><li>两个字节表示的数的最小值：0000 0000 0000 0000 for 0   means 0。</li><li>两个字节表示的数的最大值：1111 1111 1111 1111 for 65535 means 2 ^ 16 - 1。</li><li>四个字节(bytes) &#x3D; 32位(bits) <code>无符号</code>：<strong>0~4294967295</strong> <code>有符号</code> <strong>-2147483648~2147483647。</strong></li><li>四个字节表示的数的最小值：0000 0000 0000 0000 0000 0000 0000 0000。</li><li>四个字节表示的数的最大值：1111 1111 1111 1111 1111 1111 1111 1111。</li><li>八个字节(bytes) &#x3D; 64位(bits) <strong>很大的数</strong> 。</li><li>八个字节表示的数的最小值：0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000。</li><li>八个字节表示的数的最大值：1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111。</li></ul><p><code>tip</code>：<code>IPv6</code>：<strong>16个字节</strong></p><p><strong>基本的进制运算</strong></p><ul><li><p>16进制：<code>0x121</code> &#x3D; 1 * 16 ^ 2 + 2 * 16 ^ 1 + 1 * 16 ^ 0 。</p></li><li><p>8进制：<code>0121</code> &#x3D; 1 * 8 ^ 2 + 2 * 8 ^ 1 + 1 * 8 ^0。</p></li><li><p>二进制：<code>10011100</code> &#x3D; <code>0x9C</code> &#x3D; 9 * 16 ^ 1 + 12 * 16 ^ 0 &#x3D; 156。</p></li></ul><table><thead><tr><th align="center">十六进制</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th><th align="center">G</th></tr></thead><tbody><tr><td align="center">十进制</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">9</td><td align="center">10</td><td align="center">11</td><td align="center">12</td><td align="center">13</td><td align="center">14</td><td align="center">15</td><td align="center">16</td></tr><tr><td align="center">八进制</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">10</td><td align="center">11</td><td align="center">12</td><td align="center">13</td><td align="center">14</td><td align="center">15</td><td align="center">16</td><td align="center">17</td><td align="center">20</td></tr><tr><td align="center">二进制</td><td align="center">0000 0000</td><td align="center">0000 0001</td><td align="center">0000 0010</td><td align="center">0000 0011</td><td align="center">0000 0100</td><td align="center">0000 0101</td><td align="center">0000 0110</td><td align="center">0000 0111</td><td align="center">0000 1000</td><td align="center">0000 1001</td><td align="center">0000 1010</td><td align="center">0000 1011</td><td align="center">0000 1100</td><td align="center">0000 1101</td><td align="center">0000 1110</td><td align="center">0000 1111</td><td align="center">0001 0000</td></tr></tbody></table><p><strong>基本数据类型</strong></p><ul><li><code>int</code> 类型(integer)，整形，占4个字节，32位bit，表示范围 <strong>-2147483648~2147483647。</strong></li><li><code>short</code> 类型，短整型，占2个字节，16位bit，表示范围  <strong>-32768~32767</strong>。</li><li><code>long</code> 类型，长整型，占8个字节，64位bit，表示范围 <strong>很大</strong>。</li><li><code>char</code> 类型，字符类型，占1个字节，8位，表示范围：<strong>0~255</strong>，可以表示共256个字符，其中&#x2F;0用作字符串的结束符。</li><li><code>float</code> 类型，浮点型，占4个字节，32位，<code>1位数符</code>，<code>8位阶码</code> ，<code>23位尾数</code>。</li><li><code>double</code> 类型，双精度浮点型，占8个字节，64位，<code>1位数符</code>，<code>11位阶码</code> ，<code>52位尾数</code>。</li><li></li></ul><hr><h2 id="2-C语言运算符和表达式"><a href="#2-C语言运算符和表达式" class="headerlink" title="2. C语言运算符和表达式"></a>2. C语言运算符和表达式</h2><p><strong><code>tip</code>：左值和右值</strong></p><ul><li><p>左值：</p><ul><li><p><strong>能够出现在赋值语句左侧的表达式</strong>：</p><p>C语言中的左值（Lvalue，意为左值表达式）指的是<code>能出现在赋值语句左边</code>的表达式，即指向一个明确存储位置的表达式。左值表示的是对象的身份，它引用的是内存中一个具体而持久的位置。</p></li><li><p>可以将左值视为<strong>可以被赋值的实体</strong>，因为它指向的是一个可变更的存储位置。</p></li><li><p><strong>左值不仅限于变量，它也可以是更复杂的表达式</strong></p><ul><li>数组元素的引用；</li><li>解引用指针操作得到的结果；</li><li>只要一个变量或者表达式指向一个确切的存储位置，并且可以被赋值。</li></ul></li></ul></li><li><p>右值：，右值是指不能位于赋值语句左边的表达式，它通常代表数据值，而不是存储位置。简单来说，右值是表达式计算后的值，或者是无法被赋值的临时量。字面常量 <code>10</code> 或者<code>运算符的结果</code>都是右值。</p></li><li><p><code>&amp;</code> 运算符只能作用于一个左值。</p></li></ul><p><code>tip</code>：运算符的本质：在底层实现上，运算符代表着编译器在编译代码时应当生成何种机器指令来执行这些运算。例如，加法运算符会对应生成将两个数相加的机器指令。</p><p>运算符作用的结果：为一个右值，可以是一个常量也可以是一个变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> result = a + b; <span class="hljs-comment">// 结果取决于a和b的值 是一个变量</span><br><span class="hljs-type">int</span> result = <span class="hljs-number">3</span> + <span class="hljs-number">4</span>; <span class="hljs-comment">// 结果为一个常量</span><br><span class="hljs-type">int</span> result =  rand() % <span class="hljs-number">10</span>; <span class="hljs-comment">// 结果是一个随机数，依然是一个变量</span><br></code></pre></td></tr></table></figure><p><strong>算数运算符</strong></p><p>以下以：X &#x3D; 100，Y &#x3D; 30 为例</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">两个操作数相加，其结果为一个右值</td><td align="center">X+Y的结果为130</td></tr><tr><td align="center">-</td><td align="center">第一个数减去第二个数，其结果是一个右值</td><td align="center">X-Y的结果为70</td></tr><tr><td align="center">*</td><td align="center">两个操作数相乘，其结果是一个右值</td><td align="center">X*Y的结果是300</td></tr><tr><td align="center">&#x2F;</td><td align="center">左侧的操作数除以右侧的操作数，其结果是一个右值</td><td align="center">X&#x2F;Y的结果为3，两个整数相除，其结果为一个整数，舍弃小数部分；只有两个浮点数相除时，其结果才会是小数。</td></tr><tr><td align="center">%</td><td align="center">取模运算，含义上为整除后的余数</td><td align="center">X%Y的结果为10</td></tr><tr><td align="center">++</td><td align="center">自加运算，作用于整数，结果为原操作数加1</td><td align="center">X++得到101</td></tr><tr><td align="center">–</td><td align="center">自加运算，作用于整数，结果为原操作数减1</td><td align="center">X–得到99</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> numX = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> numY = <span class="hljs-number">30</span>;<br><br><span class="hljs-type">int</span> sum;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum:%d\n&quot;</span>, sum = num1 + num2); <span class="hljs-comment">// 运算符加法 打印sum的值</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum:%d\n&quot;</span>, sum); <span class="hljs-comment">// 打印sum的值 为130</span><br></code></pre></td></tr></table></figure><p>关于<code>++X</code>和<code>X++</code>：</p><ul><li>X++：先取X的值，后执行+1操作；</li><li>++X：先执行+1操作，后取X的值。</li></ul><hr><p><strong>逻辑运算符</strong></p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">真值表</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">逻辑<strong>与</strong>运算符，全真为真，有假为假</td><td align="center">0 &amp;&amp; 0 -&gt; 0，0 &amp;&amp; 1 -&gt; 0，1 &amp;&amp; 0 -&gt; 0，1 &amp;&amp; 1 -&gt; 1</td></tr><tr><td align="center">||</td><td align="center">逻辑<strong>或</strong>运算符，有真为真，全假为假</td><td align="center">0 &amp;&amp; 0 -&gt; 0，0 &amp;&amp; 1 -&gt; 1，1 &amp;&amp; 0 -&gt; 1，1 &amp;&amp; 1 -&gt; 1</td></tr><tr><td align="center">！</td><td align="center">逻辑<strong>非</strong>运算符，真变为假，假变为真</td><td align="center">! 0 -&gt; 1，! 1 -&gt; 0</td></tr></tbody></table><p><code>tip</code>：关于<code>||</code>运算，如果左边以及确定为真，那么右边的运算符则会默认不执行。</p><hr><p><strong>条件表达式</strong></p><p><code>tip</code>：条件表达式的结果只能为<code>1</code>或<code>0</code>。</p><table><thead><tr><th align="center">表达式</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">&#x3D;&#x3D;</td><td align="center">判断左侧表达式与右侧编码上是否相等</td><td align="center"><code>char</code>类型的本质是<code>0~255</code>的数字，因此部分数字与char类型判断可能是相等的，例如<code>0==&#39;\0&#39;</code>的输出结果为<code>1</code>.</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><hr><h2 id="3-C语言条件语句"><a href="#3-C语言条件语句" class="headerlink" title="3. C语言条件语句"></a>3. C语言条件语句</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 条件语句1 */</span>)<br>&#123;<br>    <span class="hljs-comment">/* 条件语句1返回值为1执行代码 */</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-comment">/* 条件语句2 */</span>)<br>&#123;<br><span class="hljs-comment">/* 条件语句1返回值为0,条件语句2返回值为1执行代码 */</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">/* 条件语句1和2返回值都为0执行代码 */</span><br>&#125;    <br></code></pre></td></tr></table></figure><hr><h2 id="4-C语言条件选择语句"><a href="#4-C语言条件选择语句" class="headerlink" title="4. C语言条件选择语句"></a>4. C语言条件选择语句</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (<span class="hljs-comment">/* 表达式 */</span>)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-comment">/* 常量表达式1 */</span>:<br>    <span class="hljs-comment">/* 满足常量表达式1时的执行代码 */</span><br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-comment">/* 常量表达式2 */</span>:<br>    <span class="hljs-comment">/* 不满足常量表达式1,但满足常量表达式2时的执行代码 */</span><br>    <span class="hljs-keyword">break</span>;<br>……<br>……<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">/* 所有常量表达式都不满足时，执行代码 */</span><br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>switch</code>表达式的每一个<code>case</code>条件下都需要在代码执行结尾执行一个<code>break</code>语句，否则代码会顺序执行到下一个<code>break</code>语句或者知道代码段结束。</p><p><code>tip</code>：<code>switch</code>选择的表达式只能是<code>整数</code>或者<code>字符串</code>。</p><hr><h2 id="5-C语言预编译"><a href="#5-C语言预编译" class="headerlink" title="5. C语言预编译"></a>5. C语言预编译</h2><p>#后的内容为预编译语句</p><ul><li><code>#ifndef</code> <code>#define</code> <code>#endif</code> 哟版用于<code>.h</code>头文件，用来防止重复定义头文件</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MYADD_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MYADD_H__</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">myAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li><p><code>#define</code> 在程序预编译时对程序中的预编译的内容进行替换。</p></li><li><p><code>#if...#elif...#eles...#endif</code> 条件编译。</p><ul><li><code>if 0</code>自动注释后面的代码，编译时不生成机器指令。</li></ul></li></ul><hr><h2 id="6-C语言格式化输出"><a href="#6-C语言格式化输出" class="headerlink" title="6. C语言格式化输出"></a>6. C语言格式化输出</h2><ul><li><code>%d</code> 格式化输出整数。</li><li><code>%s</code> 格式化输出字符串。</li><li><code>%p</code> 格式化输出地址。</li><li><code>%c</code> 格式化输出字符。</li><li><code>%f</code> 格式化输出浮点型。</li></ul><hr><h2 id="7-C语言循环语句"><a href="#7-C语言循环语句" class="headerlink" title="7. C语言循环语句"></a>7. C语言循环语句</h2><p>C语言的三种循环语句：</p><ul><li><code>while</code> 一般用于循环次数未知的情况。‘</li><li><code>do while</code> 先运行一次函数体，在执行条件判断语句，先执行后判断。</li><li><code>for</code> 一般用于循环次数已知或者可以预测的情况。</li></ul><p><code>for</code>循环执行顺序如下，初始化语句只执行一次：</p><img src="/2024/01/28/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/pic.jpg" class=""><hr><h2 id="8-C语言数组"><a href="#8-C语言数组" class="headerlink" title="8. C语言数组"></a>8. C语言数组</h2><ul><li>数组一般是一个连续的地址空间。</li><li>数组中存放相同的数据类型。</li><li>在初始化数组时，需要对数组中的脏数据进行清理，一般使用<code>memset</code>函数惊醒清理。</li><li>数组在定义时需要指定数组的元素个数。</li><li><code>数组名</code>的本质是数组的<code>首地址</code>，也是<code>第一个数组元素</code>所存放的地址。</li><li>数组长度为数组类型所占的字节数 * 数组中变量的个数。</li><li>数组作为<code>函数变量</code>时会自动退化为<code>指针</code>，因此数组作为函数变量时必须指定数组的长度。</li></ul><hr><h2 id="9-C语言内存"><a href="#9-C语言内存" class="headerlink" title="9. C语言内存"></a>9. C语言内存</h2><p>内存共有四个分区</p><ol><li>非法地址区：<code>0~4个字节</code></li><li>全局区：没有大小概念，存储字符串常量</li><li>堆区：堆区的大小与内存条大小有关，对程序员可见，<code>malloc</code>申请内存空间</li><li>栈区：<code>8MB</code>，系统自动分配</li></ol><p><code>tip</code>：C语言函数中的所有普通变量(数据类型修饰的变量)都存放在栈区。</p><hr><h2 id="10-C语言函数"><a href="#10-C语言函数" class="headerlink" title="10. C语言函数"></a>10. C语言函数</h2><p>C语言函数的三要素：</p><ul><li><p>函数名：见名知意</p></li><li><p>函数参数：</p><ul><li><p>传入参数</p><p>在函数中可以被修改或者引用的参数。</p><ul><li><code>整形数据</code>：没有指针修饰的就是传入参数，即<code>值传递</code></li><li><code>字符串</code>：没有<code>const</code>修饰的变量就是传入参数，这样的变量在函数中可以自由被修改。</li></ul></li><li><p>传出参数：</p><p>由于函数只有一个返回值，当需要对多个参数进行修改时，就会用到传出参数，即参数本生一般没有值或者是在函数中需要进行更改的变量。</p><ul><li><p><code>整形数据</code>：有指针修饰的就是传出参数，即<code>地址传递</code></p></li><li><p><code>字符串</code>：被<code>const</code>修饰的变量就是传出参数。</p><p><code>tip</code>：const修饰的是<code>char *</code>，即不能被修改的是 字符指针变量而不是字符串本身，因此在函数中字符串还是可以被修改并作为传出参数的。</p></li></ul></li></ul></li><li><p>函数返回值</p></li></ul><hr><h2 id="11-C语言字符串"><a href="#11-C语言字符串" class="headerlink" title="11. C语言字符串"></a>11. C语言字符串</h2><ul><li>字符串存放位置：<code>全局区</code></li></ul><p>C语言字符串的4中声明类型：</p><ul><li>其中<code>赋值方式2</code>和<code>赋值方式3</code>由于是双引号声明的变量，因此在结尾会加一个<code>\0</code></li><li><code>tip</code>：<code>strlen</code>与<code>sizeof</code>的区别</li></ul><p><code>sizeof</code>:</p><p>一般来说，<code>sizeof</code>用于计算数据的长度，即所占字节数。</p><table><thead><tr><th align="center">用途</th><th>举例</th><th align="center">结果</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><code>sizeof(字符串指针)</code></td><td>char *pa &#x3D; “hello world”</td><td align="center">8</td><td align="center">作为字符串指针，那么它的数据类型为指针类型，指针类型固定占8字节内存。</td></tr><tr><td align="center"><code>sizeof(基本数据类型)</code></td><td>int a &#x3D; 100</td><td align="center">数据类型所占的字节数</td><td align="center">&#x2F;</td></tr><tr><td align="center"><code>sizeof(不定长字符数组)</code></td><td>char array[] &#x3D; “hello world”</td><td align="center">12</td><td align="center">当需要计算的数据类型是数组时，<code>sizeof(array)</code>所代表的是一整个数组的长度(字符串长度加上一个<code>\0</code>，<code>11 + 1 = 12</code>)，数组的声明实际上相当于<code>char[] array = &quot;hello world&quot;</code>，即整个<code>char[]</code>为array的数据类型。</td></tr><tr><td align="center"><code>sizeof(定长字符数组)</code></td><td>char array[20]</td><td align="center">20</td><td align="center">含义同上，相当于<code>char[20] array</code>。其结果为20个<code>char</code>类型变量的总长度。</td></tr></tbody></table><p><code>sizeof</code>和<code>strlen</code>的区别于联系：</p><table><thead><tr><th align="center"></th><th align="center">用途</th><th align="center">字符数组的大小</th></tr></thead><tbody><tr><td align="center"><code>sizeof</code></td><td align="center">计算数据大小</td><td align="center">当声明字符数组时<code>声明了字符数组的大小</code>，那么结果就是所声明的大小；如果<code>未指定字符数组的大小</code>，那么计算结果就是字符串的长度加上一个<code>\0</code>的大小，例如”hello world”，字符串长度为11个字节，加上一个<code>\0</code>为12个字节。</td></tr><tr><td align="center"><code>strlen</code></td><td align="center">计算字符串的长度</td><td align="center">这个函数返回的是当前字符串的长度，不包含<code>\0</code>，因此同样对于一个字符串”hello world”，这个函数的计算结果则是<code>11</code>。然而，由于<code>strlen</code>函数的特性，并且只有以被<code>双引号</code>包起来的字符串才<code>会在末尾自动加一个\0</code>。当没有找到<code>\0</code>时，它就会一直往下计算，因此当一个函数声明了多个字符数组，或者存在脏数据时，这个函数会产生运算错误。</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* 字符数组 */</span><br><span class="hljs-type">char</span> buffer[BUFFER_SIZE];<br><span class="hljs-comment">/* 清理脏数据 */</span><br><span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buffer));<br><br><span class="hljs-comment">// 字符赋值方式1:</span><br>buffer[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;h&#x27;</span>;<br>buffer[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;e&#x27;</span>;<br><br><span class="hljs-comment">// 字符赋值方式2:</span><br><span class="hljs-comment">/* strcpy 目的操作数 源操作数 */</span><br><span class="hljs-built_in">strcpy</span>(buffer, <span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buffer:%s\n&quot;</span>, buffer);<br><br><span class="hljs-comment">// 字符赋值方式3:直接赋值</span><br><span class="hljs-type">char</span> buffer2[BUFFER_SIZE] = <span class="hljs-string">&quot;hello world&quot;</span>; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buffer2:%s\n&quot;</span>, buffer2);<br><br><span class="hljs-comment">// 字符赋值方式4:直接赋值</span><br><span class="hljs-type">char</span> buffer3[BUFFER_SIZE] = &#123;<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buffer3:%s\n&quot;</span>, buffer3);<br></code></pre></td></tr></table></figure><hr><h2 id="12-C语言指针"><a href="#12-C语言指针" class="headerlink" title="12. C语言指针"></a>12. C语言指针</h2><p>介绍两个指针相关的运算符。</p><ul><li><code>*</code> 既可以充当指针变量的声明，也是运算符<code>解引用</code>符号。</li><li><code>&amp;</code> 取地址符号。</li></ul><p>只有指针类型的变量才能与<code>*</code>运算符结合，结合后得到的内容是当前指针指向的内存空间所保存的数据，可能是任何类型的数据。</p><p>只有保存在内存空间中的数据才能与<code>&amp;</code>运算符结合，结合后得到的内容是当前数据所在的地址空间，是一个之战类型的数据。</p><p><code>tip</code>：指针类型的数据本质就是<code>地址</code>，占<code>8个字节</code>，但是由于操作系统分页存储的原因，在打印时一般只显示6字节的地址内容，高16位表示页号。</p><p><code>tip</code>：所有<code>指针</code>类型数据就是<code>地址</code>，<code>地址</code>也是<code>指针</code>类型的数据。但是指针所指向的内容要看指针所指向的内存空间的数据类型，可能是任意类型数据。</p><img src="/2024/01/28/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/pic-1706016047455-4.jpg" class=""><p><strong>二级指针</strong></p><ul><li>二级指针的本质也是指针。</li><li>该二级指针修饰的类型是 <code>int **</code>，变量名为<code>ppa</code>。</li><li><code>*</code>作用于二级指针所得到的数据还是一个地址，或者说还是一个指针类型数据。</li><li>二级指针指向的指针数据为<code>*ppa</code>，在内容上与<code>pa</code>相同。</li></ul><img src="/2024/01/28/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image-20240125094618917.png" class=""><p><strong>使用指针</strong></p><ul><li><p>声明指针类型数据必须进行初始化，如果暂时不能确定指针所指向的地址空间，则需要对指针赋值<code>NULL</code>，指向地址空间<code>0x00</code>，但是这块地址空间是非法的，对这块内存空间进行任何操作都会导致段错误<code>Segmentation fault (core dumped)</code>。</p></li><li><p>在使用指针作为函数参数时，在函数中第一步必须进行判空。</p><p><strong>判空后操作</strong></p><ul><li><p>如果空指针在这个函数中是非法的，那么需要立即终值函数。</p><ul><li><p>终止操作：</p><p><code>perror(&quot;错误信息&quot;);</code></p><p><code>exit(-1);</code></p></li></ul></li><li><p>如果后续需要使用到这个指针，那么必须对这个指针数据<code>pointer</code>进行初始化。</p><ul><li><p>假设这个指针为：<code>char *pointer = NULL;</code></p><p><code>pointer = (char *)malloc(size);</code></p><p><code>size</code>必须以参数的形式通过函数传递。</p></li></ul></li></ul></li></ul><hr><h2 id="13-gdb调试"><a href="#13-gdb调试" class="headerlink" title="13. gdb调试"></a>13. <strong>gdb</strong>调试</h2><p>使用以下命令对一个<code>.c</code>进行<code>gdb</code>调试：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc -g [文件名] # 以debug方式编译C语言文件<br>apt install gdb # 下载gdb调试器<br><br>gdb [编译好的可执行文件] # 进入gdb调试<br># gdb调试命令<br>b [行号] # 在某一行添加断点<br>b [函数名] # 在函数入口处添加断点<br><br><span class="hljs-built_in">del</span> [断点序号] # 删除断点<br><br>run # 运行函数<br>s # 进入函数内部<br>n # 进入下一行<br>p &amp;[变量] # 打印变量地址<br></code></pre></td></tr></table></figure><p><code>tip</code>：使用<code>gdb</code>调试检查程序段错误<code>Segmentation fault (core dumped)</code>。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc -g demoCharPointer.c<br>gdb a.out<br>run<br># 会在末尾处打印段错误信息。<br></code></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">root@iZbp11t02fism5k702usgjZ:/<span class="hljs-title">home</span>/257<span class="hljs-title">class</span>/<span class="hljs-title">BasiC</span>/<span class="hljs-title">BasiC</span>/<span class="hljs-title">pointer</span># <span class="hljs-title">gcc</span> -<span class="hljs-title">g</span> <span class="hljs-title">demoCharPointer.c</span></span><br><span class="hljs-function"><span class="hljs-title">root</span>@<span class="hljs-title">iZbp11t02fism5k702usgjZ</span>:/<span class="hljs-title">home</span>/257<span class="hljs-title">class</span>/<span class="hljs-title">BasiC</span>/<span class="hljs-title">BasiC</span>/<span class="hljs-title">pointer</span># <span class="hljs-title">gdb</span> <span class="hljs-title">a.out</span></span><br><span class="hljs-function"><span class="hljs-title">GNU</span> <span class="hljs-title">gdb</span> (<span class="hljs-title">Ubuntu</span> 12.1-0<span class="hljs-title">ubuntu1</span>~22.04) 12.1</span><br><span class="hljs-function"><span class="hljs-title">Copyright</span> (<span class="hljs-title">C</span>) 2022 <span class="hljs-title">Free</span> <span class="hljs-title">Software</span> <span class="hljs-title">Foundation</span>, <span class="hljs-title">Inc</span>.</span><br><span class="hljs-function"><span class="hljs-title">License</span> <span class="hljs-title">GPLv3</span>+: <span class="hljs-title">GNU</span> <span class="hljs-title">GPL</span> <span class="hljs-title">version</span> 3 <span class="hljs-title">or</span> <span class="hljs-title">later</span> &lt;<span class="hljs-title">http</span>://<span class="hljs-title">gnu.org</span>/<span class="hljs-title">licenses</span>/<span class="hljs-title">gpl.html</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">This</span> <span class="hljs-title">is</span> <span class="hljs-title">free</span> <span class="hljs-title">software</span>: <span class="hljs-title">you</span> <span class="hljs-title">are</span> <span class="hljs-title">free</span> <span class="hljs-title">to</span> <span class="hljs-title">change</span> <span class="hljs-title">and</span> <span class="hljs-title">redistribute</span> <span class="hljs-title">it</span>.</span><br><span class="hljs-function"><span class="hljs-title">There</span> <span class="hljs-title">is</span> <span class="hljs-title">NO</span> <span class="hljs-title">WARRANTY</span>, <span class="hljs-title">to</span> <span class="hljs-title">the</span> <span class="hljs-title">extent</span> <span class="hljs-title">permitted</span> <span class="hljs-title">by</span> <span class="hljs-title">law</span>.</span><br><span class="hljs-function"><span class="hljs-title">Type</span> &quot;<span class="hljs-title">show</span> <span class="hljs-title">copying</span>&quot; <span class="hljs-title">and</span> &quot;<span class="hljs-title">show</span> <span class="hljs-title">warranty</span>&quot; <span class="hljs-title">for</span> <span class="hljs-title">details</span>.</span><br><span class="hljs-function"><span class="hljs-title">This</span> <span class="hljs-title">GDB</span> <span class="hljs-title">was</span> <span class="hljs-title">configured</span> <span class="hljs-title">as</span> &quot;<span class="hljs-title">x86_64</span>-<span class="hljs-title">linux</span>-<span class="hljs-title">gnu</span>&quot;.</span><br><span class="hljs-function"><span class="hljs-title">Type</span> &quot;<span class="hljs-title">show</span> <span class="hljs-title">configuration</span>&quot; <span class="hljs-title">for</span> <span class="hljs-title">configuration</span> <span class="hljs-title">details</span>.</span><br><span class="hljs-function"><span class="hljs-title">For</span> <span class="hljs-title">bug</span> <span class="hljs-title">reporting</span> <span class="hljs-title">instructions</span>, <span class="hljs-title">please</span> <span class="hljs-title">see</span>:</span><br><span class="hljs-function">&lt;<span class="hljs-title">https</span>://<span class="hljs-title">www.gnu.org</span>/<span class="hljs-title">software</span>/<span class="hljs-title">gdb</span>/<span class="hljs-title">bugs</span>/&gt;.</span><br><span class="hljs-function"><span class="hljs-title">Find</span> <span class="hljs-title">the</span> <span class="hljs-title">GDB</span> <span class="hljs-title">manual</span> <span class="hljs-title">and</span> <span class="hljs-title">other</span> <span class="hljs-title">documentation</span> <span class="hljs-title">resources</span> <span class="hljs-title">online</span> <span class="hljs-title">at</span>:</span><br><span class="hljs-function">--<span class="hljs-title">Type</span> &lt;<span class="hljs-title">RET</span>&gt; <span class="hljs-title">for</span> <span class="hljs-title">more</span>, <span class="hljs-title">q</span> <span class="hljs-title">to</span> <span class="hljs-title">quit</span>, <span class="hljs-title">c</span> <span class="hljs-title">to</span> <span class="hljs-title">continue</span> <span class="hljs-title">without</span> <span class="hljs-title">paging</span>--<span class="hljs-title">c</span></span><br><span class="hljs-function">    &lt;<span class="hljs-title">http</span>://<span class="hljs-title">www.gnu.org</span>/<span class="hljs-title">software</span>/<span class="hljs-title">gdb</span>/<span class="hljs-title">documentation</span>/&gt;.</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">For</span> <span class="hljs-title">help</span>, <span class="hljs-title">type</span> &quot;<span class="hljs-title">help</span>&quot;.</span><br><span class="hljs-function"><span class="hljs-title">Type</span> &quot;<span class="hljs-title">apropos</span> <span class="hljs-title">word</span>&quot; <span class="hljs-title">to</span> <span class="hljs-title">search</span> <span class="hljs-title">for</span> <span class="hljs-title">commands</span> <span class="hljs-title">related</span> <span class="hljs-title">to</span> &quot;<span class="hljs-title">word</span>&quot;...</span><br><span class="hljs-function"><span class="hljs-title">Reading</span> <span class="hljs-title">symbols</span> <span class="hljs-title">from</span> <span class="hljs-title">a.out</span>...</span><br><span class="hljs-function">(<span class="hljs-title">gdb</span>) <span class="hljs-title">run</span></span><br><span class="hljs-function"><span class="hljs-title">Starting</span> <span class="hljs-title">program</span>: /<span class="hljs-title">home</span>/257<span class="hljs-title">class</span>/<span class="hljs-title">BasiC</span>/<span class="hljs-title">BasiC</span>/<span class="hljs-title">pointer</span>/<span class="hljs-title">a.out</span> </span><br><span class="hljs-function">[<span class="hljs-title">Thread</span> <span class="hljs-title">debugging</span> <span class="hljs-title">using</span> <span class="hljs-title">libthread_db</span> <span class="hljs-title">enabled</span>]</span><br><span class="hljs-function"><span class="hljs-title">Using</span> <span class="hljs-title">host</span> <span class="hljs-title">libthread_db</span> <span class="hljs-title">library</span> &quot;/<span class="hljs-title">lib</span>/<span class="hljs-title">x86_64</span>-<span class="hljs-title">linux</span>-<span class="hljs-title">gnu</span>/<span class="hljs-title">libthread_db.so</span>.1&quot;.</span><br><span class="hljs-function"><span class="hljs-title">len</span>:8</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">Program</span> <span class="hljs-title">received</span> <span class="hljs-title">signal</span> <span class="hljs-title">SIGSEGV</span>, <span class="hljs-title">Segmentation</span> <span class="hljs-title">fault</span>.</span><br><span class="hljs-function">0<span class="hljs-title">x0000555555555192</span> <span class="hljs-title">in</span> <span class="hljs-title">main</span> (<span class="hljs-title">argc</span>=1, <span class="hljs-title">argv</span>=0<span class="hljs-title">x7fffffffe198</span>) <span class="hljs-title">at</span> <span class="hljs-title">demoCharPointer.c</span>:12</span><br><span class="hljs-function">12          <span class="hljs-title">strcpy</span>(<span class="hljs-title">ptr</span>, &quot;<span class="hljs-title">hello</span> <span class="hljs-title">world</span>&quot;);</span><br><span class="hljs-function">(<span class="hljs-title">gdb</span>) </span><br></code></pre></td></tr></table></figure><hr><h2 id="14-字符串与字符数组"><a href="#14-字符串与字符数组" class="headerlink" title="14. 字符串与字符数组"></a>14. 字符串与字符数组</h2><p><strong>字符串存放位置</strong>：<code>全局区</code></p><p><code>字符串</code>：</p><ul><li>所有用双引号括起来的都是字符串。</li><li>所有字符串都会在末尾处添加一个<code>\0</code>作为结束标志。</li><li>字符串长度为：<code>字符个数+1</code></li></ul><p><code>字符数组</code>：</p><ul><li>字符数组的大小为数组大小。</li><li>使用以下两种方式初始化字符数组时，不会在末尾自动添加<code>\0</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> buffer[BUFFER_SIZE];<br><span class="hljs-comment">/* 清理脏数据 */</span><br><span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buffer));<br><span class="hljs-comment">// 字符赋值方式1:</span><br>buffer[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;h&#x27;</span>;<br>buffer[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;e&#x27;</span>;<br><span class="hljs-comment">// 字符赋值方式4:</span><br><span class="hljs-type">char</span> buffer3[BUFFER_SIZE] = &#123;<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;; <br></code></pre></td></tr></table></figure><ul><li>使用以下方式初始化字符数组会在末尾添加<code>\0</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 字符赋值方式2:</span><br><span class="hljs-built_in">strcpy</span>(buffer, <span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-comment">// 字符赋值方式3:</span><br><span class="hljs-type">char</span> buffer2[BUFFER_SIZE] = <span class="hljs-string">&quot;hello world&quot;</span>; <br></code></pre></td></tr></table></figure><ul><li>对字符数组&#x3D;赋值时，后面跟着的字符串长度可能会超出字符数组的大小，这个时候就有可能访问到一些不能被访问的内存，这个操作就叫做<code>踩内存</code>，而这种操作是不被允许的。</li></ul><p>字符串和字符数组的内存分配：</p><ul><li>字符数组在声明时自动在<code>栈</code>空间分配内存，这也是其他基本数据类型的分配内存方式；</li><li>字符串指针初始化时，如果不对其赋初值，那么必须使其指向<code>NULL</code>，其内存空间为<code>0x00</code>;</li><li>系统中程序员分配的空间为堆空间，可以使用<code>malloc</code>函数初始化申请空间。并且所有malloc申请的内存空间都要进行<code>判空</code>操作，且在用完后都要进行<code>free</code>释放内存。</li></ul><p><img src="/./assets/pic-1706251623850-3.jpg" alt="pic"></p><hr><h2 id="15-堆泄漏"><a href="#15-堆泄漏" class="headerlink" title="15. 堆泄漏"></a>15. 堆泄漏</h2><p>有三种堆泄漏的情况</p><ul><li><code>野指针</code>：声明指针类型数据，但是没有初始化，如<code>char *ptr;</code>。</li><li><code>malloc申请的内存空间没有释放</code>。</li><li><code>踩内存</code>：访问了原本不属于变量自己的内存空间就叫做踩内存，一般发生在数组中。<ul><li><code>int array[20]; array[21] = 0;</code>。</li><li><code>for</code>循环数组下表访问不当也会引起这样的问题。</li></ul></li></ul><p>检查内存泄漏的命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">valgrind --tool=memcheck --leak-check=yes --show-reachable=yes ./[需要检查的.exe文件]<br></code></pre></td></tr></table></figure><hr><h2 id="16-指针即数组"><a href="#16-指针即数组" class="headerlink" title="16. 指针即数组"></a>16. 指针即数组</h2><p>声明数组变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arrray[<span class="hljs-number">20</span>];<br></code></pre></td></tr></table></figure><p>上述代码等价于<code>int[20] array </code></p><ul><li>表示变量<code>array</code>是一个有<code>20个int空间</code>的数组类型变量。</li><li>同时<code>array</code>也是这20个数组空间的首地址。</li><li><code>array</code>与<code>&amp;array[0]</code>是相同的。</li><li>同时<code>array</code>与<code>&amp;array[0]</code>都是地址数据，同时也是指针类型的变量。</li></ul><p><code>tip</code>：数组作为函数变量时会自动退化为指针，因此数组作为函数变量时必须指定数组的长度。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>argc</code>为传入参数的个数</p></li><li><p><code>argv</code>为传入参数的地址列表</p></li></ul><hr><h2 id="17-二维数组与二维指针"><a href="#17-二维数组与二维指针" class="headerlink" title="17. 二维数组与二维指针"></a>17. 二维数组与二维指针</h2><p><strong>二维数组是由一维数组构成的：</strong></p><p><code>int array[ROW][COLUMN]</code>，<code>加一</code>作用于不同的变量，它加上的值是不同的：</p><ul><li><code>array</code>，array为二级指针，即指向指针的指针。<code>+1</code>作用于<code>array</code>，<code>array</code>的值加上<code>4 * COLUMN</code>。</li><li><code>*array</code>或者<code>array[x]</code>，它们都是一级指针。<code>+1</code>作用于它们，它们的值加上<code>4</code>.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ROW 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COLUMN 3</span><br><br><span class="hljs-comment">// 二维数组</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>];<br><br>    <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 不是自己的空间不能放</span><br>    <span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 1</span><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[ROW][COLUMN];<br>    <span class="hljs-built_in">memset</span>(<span class="hljs-built_in">array</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">array</span>));<br>    <span class="hljs-comment">/*  1.占用内存大小 */</span><br>    <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">array</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;len:%d\n&quot;</span>, len);<br><br>    <span class="hljs-comment">/*  2.赋值 */</span><br>    <span class="hljs-comment">// a[0][0] = 0;</span><br>    <span class="hljs-type">int</span> value = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>; idx &lt; ROW; idx++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> jdx = <span class="hljs-number">0</span>; jdx &lt; COLUMN; jdx++)<br>        &#123;<br>            <span class="hljs-built_in">array</span>[idx][jdx] = value++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array = %p\n&quot;</span>, <span class="hljs-built_in">array</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array + 1 = %p\n&quot;</span>, <span class="hljs-built_in">array</span> + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array[0] = %p\n&quot;</span>, <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array[0] + 1 = %p\n&quot;</span>, <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*array = %p\n&quot;</span>, *<span class="hljs-built_in">array</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*array + 1 = %p\n&quot;</span>, *<span class="hljs-built_in">array</span> + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*(array[0]) = %d\n&quot;</span>, *(<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;**array = %d\n&quot;</span>, **<span class="hljs-built_in">array</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;(**array) = %p\n&quot;</span>, &amp;(**<span class="hljs-built_in">array</span>));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----------------------\n&quot;</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array[1][2] = %d\n&quot;</span>, <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*(*(array + 1) + 2) = %d\n&quot;</span>, *(*(<span class="hljs-built_in">array</span> + <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;array[1][2] = %p\n&quot;</span>, &amp;<span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(*(array + 1) + 2) = %p\n&quot;</span>, *(<span class="hljs-built_in">array</span> + <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// array[1]  = *(array + 1)</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(array[1] + 2) = %p\n&quot;</span>, (<span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>] + <span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 每一行对应的地址</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array[1] = %p\n&quot;</span>, <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>]);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码打印结果：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">root@iZbp11t02fism5k702usgjZ:/<span class="hljs-title">home</span>/257<span class="hljs-title">class</span>/<span class="hljs-title">BasiC</span>/<span class="hljs-title">BasiC</span>/<span class="hljs-title">array</span># ./<span class="hljs-title">a.out</span></span><br><span class="hljs-function"><span class="hljs-title">len</span>:36</span><br><span class="hljs-function"><span class="hljs-title">array</span> = 0<span class="hljs-title">x7ffdfb683c80</span></span><br><span class="hljs-function"><span class="hljs-title">array</span> + 1 = 0<span class="hljs-title">x7ffdfb683c8c</span></span><br><span class="hljs-function"><span class="hljs-title">array</span>[0] = 0<span class="hljs-title">x7ffdfb683c80</span></span><br><span class="hljs-function"><span class="hljs-title">array</span>[0] + 1 = 0<span class="hljs-title">x7ffdfb683c84</span></span><br><span class="hljs-function">*<span class="hljs-title">array</span> = 0<span class="hljs-title">x7ffdfb683c80</span></span><br><span class="hljs-function">*<span class="hljs-title">array</span> + 1 = 0<span class="hljs-title">x7ffdfb683c84</span></span><br><span class="hljs-function">*(<span class="hljs-title">array</span>[0]) = 1</span><br><span class="hljs-function">**<span class="hljs-title">array</span> = 1</span><br><span class="hljs-function">&amp;(**<span class="hljs-title">array</span>) = 0<span class="hljs-title">x7ffdfb683c80</span></span><br><span class="hljs-function">-----------------------</span><br><span class="hljs-function"><span class="hljs-title">array</span>[1][2] = 6</span><br><span class="hljs-function">*(*(<span class="hljs-title">array</span> + 1) + 2) = 6</span><br><span class="hljs-function">&amp;<span class="hljs-title">array</span>[1][2] = 0<span class="hljs-title">x7ffdfb683c94</span></span><br><span class="hljs-function">(*(<span class="hljs-title">array</span> + 1) + 2) = 0<span class="hljs-title">x7ffdfb683c94</span></span><br><span class="hljs-function">(<span class="hljs-title">array</span>[1] + 2) = 0<span class="hljs-title">x7ffdfb683c94</span></span><br><span class="hljs-function"><span class="hljs-title">array</span>[1] = 0<span class="hljs-title">x7ffdfb683c8c</span></span><br><span class="hljs-function"><span class="hljs-title">root</span>@<span class="hljs-title">iZbp11t02fism5k702usgjZ</span>:/<span class="hljs-title">home</span>/257<span class="hljs-title">class</span>/<span class="hljs-title">BasiC</span>/<span class="hljs-title">BasiC</span>/<span class="hljs-title">array</span># </span><br></code></pre></td></tr></table></figure><h6 id=""><a href="#" class="headerlink" title=""></a><img src="/./assets/image-20240126154436534.png" alt="image-20240126154436534"></h6><hr><h2 id="18-C语言文件编译的过程"><a href="#18-C语言文件编译的过程" class="headerlink" title="18. C语言文件编译的过程"></a>18. C语言文件编译的过程</h2><p><code>预编译-&gt;编译-&gt;汇编-&gt;链接</code></p><ol><li><p>预编译</p><p>C++文件：<code>gcc -E [文件名.cpp] &gt; [预处理文件名.ii]</code>：生成<code>.ii</code>文件</p><p>C语言文件：<code>gcc -E [文件名.c] &gt; [预处理文件名.i]</code>：生成<code>.i</code>文件</p><p>预编译的工作内容</p><ul><li>展开头文件 ：<code>#include &lt;stdio.h&gt;</code></li><li>宏替换</li><li>去掉代码中的注释</li><li>条件编译</li></ul></li><li><p>编译</p><p>目标：生成<code>.s</code>文件(汇编文件)</p><p><code>gcc -S [预处理文件名.i]</code></p></li><li><p>汇编</p><p>目标：生成<code>.o</code>文件</p><p><code>gcc -c [编译文件名.s]</code></p></li><li><p>链接</p><p>目标：生成<code>.exe</code>文件</p><p><code>gcc [汇编文件名.o]</code></p></li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 示例代码<br>gcc -E main.c &gt; main.i<br>gcc -S main.i<br>gcc -c main.s<br>gcc main.o<br></code></pre></td></tr></table></figure><p><img src="/./assets/image-20240127213443580-1706429856754-6.png" alt="image-20240127213443580"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Makefile基础</title>
    <link href="/2024/01/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/01/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="makefile基础"><a href="#makefile基础" class="headerlink" title="makefile基础"></a>makefile基础</h1><h2 id="0-C语言文件编译流程。你必须明白！"><a href="#0-C语言文件编译流程。你必须明白！" class="headerlink" title="0. C语言文件编译流程。你必须明白！"></a>0. C语言文件编译流程。你必须明白！</h2><p>预编译-&gt;编译-&gt;汇编-&gt;链接</p><ol><li><p>预编译所做的事情：</p><p>C++文件：<code>gcc -E [文件名.cpp] &gt; [预处理文件名.ii]</code>：生成<code>.ii</code>文件</p><p>C语言文件：<code>gcc -E [文件名.c] &gt; [预处理文件名.i]</code>：生成<code>.i</code>文件</p><ul><li>展开头文件 ：<code>#include &lt;stdio.h&gt;</code></li><li>宏替换</li><li>去掉代码中的注释</li><li>条件编译</li></ul></li><li><p>编译</p><p><code>gcc -E [预处理文件名.i]</code>：生成<code>.s</code>文件(汇编文件)</p></li><li><p>汇编</p><p><code>gcc -c [编译文件名.s]</code>：生成<code>.o</code>文件</p></li><li><p>链接</p><p><code>gcc [汇编文件名.o]</code>：生成<code>.exe</code>文件</p></li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 示例代码<br>gcc -E main.c &gt; main.i<br>gcc -S main.i<br>gcc -c main.s<br>gcc main.o<br></code></pre></td></tr></table></figure><img src="/2024/01/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/image-20240127213443580.png" class=""><hr><h2 id="2-一个make解决所有"><a href="#2-一个make解决所有" class="headerlink" title="2. 一个make解决所有"></a>2. 一个make解决所有</h2><p>在工作目录下有多个文件需要编译时，需要大量的编译时间。</p><p>使用makefile编译程序，makefile只会编译工作目录中改动的部分代码。</p><p>这也是使用makefile编译程序的核心目的。</p><p><strong>用makefile节省你的工作时间。</strong></p><ul><li>如果target是最新生成的，那么make不会执行makefile文件中的任何命令；</li><li>如果target不存在或者target不是最新的，那么make会执行makefile文件中生成target所关联的命令，并根据需要递归地执行生成其他依赖文件的命令；</li><li>如果target关联的某些源代码文件被修改，或者target的某些依赖文件缺失，那么make会执行命令生成最新的依赖文件，并执行makefile文件中生成target所关联的命令。</li></ul><img src="/2024/01/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/image-20240127135051921.png" class=""><hr><h2 id="3-man-man-man-makefile！学会怎么使用makefile。"><a href="#3-man-man-man-makefile！学会怎么使用makefile。" class="headerlink" title="3. man man man makefile！学会怎么使用makefile。"></a>3. <strong>man man man makefile！</strong>学会怎么使用makefile。</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">make [选项] [目标] # 执行选定目标(target)命令<br>make # 默认执行第一个makefile命令<br></code></pre></td></tr></table></figure><p>一个makefile文件中包含多个makefile命令。</p><p>一个完整的makefile命令包含：</p><ol><li>目标：<strong>target</strong></li><li>依赖：<strong>dependence</strong></li><li>命令：<strong>command</strong></li></ol><p>一个正确的makefile的基本格式：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">target:dependences1 dependences2……</span><br>&lt;tab&gt;commands1 commands2……<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>command列表中的每一个<strong>命令</strong>用<code>一个空格</code>隔开</li><li>dependence列表中的每一个<strong>依赖</strong>用<code>一个空格</code>隔开</li><li>其余任何地方不能出现空格</li><li>makefile文件中的注释用<code>#</code></li></ul><img src="/2024/01/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/image-20240127224100507.png" class=""><hr><h2 id="4-用makefile命名你的makefile！禁止套娃！makefile编译过程。"><a href="#4-用makefile命名你的makefile！禁止套娃！makefile编译过程。" class="headerlink" title="4. 用makefile命名你的makefile！禁止套娃！makefile编译过程。"></a>4. 用makefile命名你的makefile！禁止套娃！makefile编译过程。</h2><img src="/2024/01/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/v2-545a34b80f7822a51d87d62d703d1607_720w.webp" class=""><p>当文件中同时存在<code>makefile</code>文件与<code>Makefile</code>文件时</p><ul><li>使用<code>make</code>命令会优先执行<code>makefile</code>文件。当没有找到<code>makefile</code>文件时，会转而寻找洽谈文件。</li><li>如果想要执行<code>Makefile</code>文件，需要使用<code>make -f Makefile</code>。</li></ul><p><strong>如果我写了很多个makefile文件，天知道我应该执行哪个！所以，只写一个叫makefile的makefile吧</strong></p><hr><h2 id="5-makefile选项，选择适合你的方式。"><a href="#5-makefile选项，选择适合你的方式。" class="headerlink" title="5. makefile选项，选择适合你的方式。"></a>5. makefile选项，选择适合你的方式。</h2><ul><li><code>-f</code> 选择<code>makefile</code>文件作为<code>make</code>命令的输入文件。</li><li><code>-B</code> 无条件执行所有目标。</li><li><code>-n</code> 只打印命令不执行命令。</li></ul><hr><h2 id="6-ERROR！是makefile的问题？不，是你的问题！"><a href="#6-ERROR！是makefile的问题？不，是你的问题！" class="headerlink" title="6. ERROR！是makefile的问题？不，是你的问题！"></a>6. ERROR！是makefile的问题？不，是你的问题！</h2><ul><li>依赖和目标拼写错误。</li><li><tab>写成了空格。</li><li>重复编译同一目标。</li><li>也许是其他文件的问题。</li></ul><hr><h2 id="7-写一个makefile吧！"><a href="#7-写一个makefile吧！" class="headerlink" title="7. 写一个makefile吧！"></a>7. 写一个makefile吧！</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">main:main.o myAdd.o myDiv.o myMinus.o myMulti.o</span><br>gcc main.o myAdd.o myDiv.o myMinus.o myMulti.o -o main<br><br><span class="hljs-section">myAdd.o:myAdd.c</span><br>gcc -c myAdd.c -o myAdd.o<br><br><span class="hljs-section">myMinus.o:myMinus.c</span><br>gcc -c myMinus.c -o myMinus.o<br><br><span class="hljs-section">myMulti.o:myMulti.c</span><br>gcc -c myMulti.c -o myMulti.o<br><br><span class="hljs-section">myDiv.o:myDiv.c</span><br>gcc -c myDiv.c -o myDiv.o<br><br><span class="hljs-section">main.o:main.c</span><br>gcc -c main.c -o main.o<br><br><span class="hljs-section">clean:</span><br>@rm -rf *.o main<br></code></pre></td></tr></table></figure><p>首先，你得有这些：</p><img src="/2024/01/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/image-20240127225643538.png" class=""><p>把上面的代码复制到makefile里面吧。</p><p><strong>然后？make！</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">make<br></code></pre></td></tr></table></figure><p>接下来会发生什么呢？</p><p>首先。</p><p>之前说过，一个<code>make</code>命令会优先找文件夹下有没有<code>makefile</code>文件。</p><p>结果就是，找到了。</p><p>可是你没有告诉<code>make</code>它的执行<code>目标(target)</code>。</p><p>那么它会默认将第一个<code>target</code>作为它的生成目标。</p><p>Oh！你的<code>target</code>叫<code>main</code>，你的最终目标是一个叫<code>main</code>的可执行文件。</p><p>那么要用到那些文件来达成你这个目标呢？</p><p><code>main.o</code> <code>myAdd.o</code> <code>myDiv.o</code> <code>myMinus.o</code> <code>myMulti.o</code> </p><p>上面的就是你的<code>dependence</code>列表了。</p><p>也就是生成你的<code>目标(target)</code>需要用到的<code>依赖(dependence)</code>。</p><p>注意到它们之间有空格，这是必须的。</p><p>接下来，编译？递归？或者说栈？</p><p><code>make</code>会根据你的<code>makefile文件</code>中描述的<code>依赖(dependence)</code>关系来生成你的<code>目标(target)</code>。</p><p>如果<code>目标(target)</code>的依赖下面还有依赖怎么办？</p><p>那当然是一层层套娃，其实就是一个自下而上的<code>递归</code>，直到所有的<code>依赖(dependence)</code>都被满足了。</p><p>这个目标才会被编译，而编译的过程就是递归调用一层一层<code>return</code>的过程。</p><p>最终，你的目标(target)实现了！</p><p>看看吧选择你的文件夹下多了一个<code>main</code>文件。</p><p>执行它，就是你想要的结果。</p><p>担心程序有bug？</p><p>那你最好使用<code>-g</code>的编译语句来书写你的makefile。</p><hr><h2 id="8-全是字母？别担心，用变量吧。"><a href="#8-全是字母？别担心，用变量吧。" class="headerlink" title="8. 全是字母？别担心，用变量吧。"></a>8. 全是字母？别担心，用变量吧。</h2><ol><li><p>系统变量</p><ul><li><p><code>$@</code>：表示目标文件的完整名称。</p></li><li><p><code>$^</code>：表示所有不重复的依赖文件</p></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 用$@替换上述代码中的目标文件，即[target]</span><br><span class="hljs-comment"># 用$……替换上述代码中的依赖文件，即[dependence]</span><br><span class="hljs-section">main:main.o myAdd.o myDiv.o myMinus.o myMulti.o</span><br>gcc <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myAdd.o:myAdd.c</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myMinus.o:myMinus.c</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myMulti.o:myMulti.c</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myDiv.o:myDiv.c</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">main.o:main.c</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">clean:</span><br>@rm -rf *.o main<br></code></pre></td></tr></table></figure></li><li><p>系统常量</p><ul><li><p><code>RM</code>：删除</p></li><li><p><code>CC</code>：C语言编译程序</p></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 用$(CC)替换上述代码中的gcc编译命令</span><br><span class="hljs-section">main:main.o myAdd.o myDiv.o myMinus.o myMulti.o</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myAdd.o:myAdd.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myMinus.o:myMinus.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myMulti.o:myMulti.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myDiv.o:myDiv.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">main.o:main.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">clean:</span><br>@<span class="hljs-variable">$(RM)</span> *.o main<br></code></pre></td></tr></table></figure></li><li><p>自定义变量</p><ul><li>使用<code>[常量名]=[值]</code>的形式定义自定义常量</li><li>使用<code>$()</code>取自定义变量的值</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OBJS=main.o myAdd.o myDiv.o myMinus.o myMulti.o<br><span class="hljs-comment"># 变量自定义赋值</span><br>TARGET=main<br><br><span class="hljs-comment"># 变量取值用$()</span><br><span class="hljs-variable">$(TARGET)</span>:<span class="hljs-variable">$(OBJS)</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myAdd.o:myAdd.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myMinus.o:myMinus.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myMulti.o:myMulti.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myDiv.o:myDiv.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">main.o:main.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">clean:</span><br>@<span class="hljs-variable">$(RM)</span> *.o main<br></code></pre></td></tr></table></figure><p>这只是一些简单的变量，其他的等待后续补充吧。</p><p>是不是简单了很多？别担心，还会更简单的！</p></li></ol><hr><h2 id="9-还是有太多冗余了，也许我该考虑更好的方法。模式匹配是个不错的选择。"><a href="#9-还是有太多冗余了，也许我该考虑更好的方法。模式匹配是个不错的选择。" class="headerlink" title="9. 还是有太多冗余了，也许我该考虑更好的方法。模式匹配是个不错的选择。"></a>9. 还是有太多冗余了，也许我该考虑更好的方法。模式匹配是个不错的选择。</h2><p>一些简单的简单的<code>makefile模式匹配</code></p><ul><li><p><code>%[目标]:%[依赖]</code>：我想不用我解释了。</p></li><li><p><code>wildcard</code>：匹配文件。</p></li></ul><p>​使用实例：获取指定目录下所有的.c文件。</p><ul><li><code>patsubst</code>：模式匹配与替换。</li></ul><p>​使用实例：指定目录下所有的.c文件替换成.o文件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 使用文件匹配替换依赖[dependence]</span><br>OBJS=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, $(<span class="hljs-built_in">wildcard</span> ./*.c)</span>)<br><span class="hljs-comment"># 变量自定义赋值</span><br>TARGET=main<br><br><span class="hljs-comment"># 变量取值用$()</span><br><span class="hljs-variable">$(TARGET)</span>:<span class="hljs-variable">$(OBJS)</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-comment"># 模式匹配 %[目标]:%[依赖]</span><br><span class="hljs-section">%.o:%.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-comment"># 伪目标(伪文件)，指执行命令，不生成文件</span><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><br><span class="hljs-section">clean:</span><br>@<span class="hljs-variable">$(RM)</span> *.o main<br><br><span class="hljs-comment"># `wildcard`：匹配文件 ()</span><br><span class="hljs-comment"># `patsubst`：模式匹配与替换</span><br><span class="hljs-section">show:</span><br>@echo <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.c)</span><br>@echo <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, $(<span class="hljs-built_in">wildcard</span> ./*.c)</span>)<br></code></pre></td></tr></table></figure><p><code>tip</code>：有个小概念，什么是伪目标？或者该叫他伪文件。</p><p>所有的目标(target)最终都会生成一个同名的目标文件。</p><p>也许有时候我不希望它生成。</p><p>这个时候就可以用<code>.PHONY: clean</code>来修饰这个<code>目标(target)</code>。</p><p>当需要生成这个<code>目标(target)</code>时，不会生成文件，而只是执行命令。</p><hr><h2 id="10-Triple-Star！最重要的一集。makefile动态库。"><a href="#10-Triple-Star！最重要的一集。makefile动态库。" class="headerlink" title="10. Triple Star！最重要的一集。makefile动态库。"></a>10. Triple Star！最重要的一集。makefile动态库。</h2><p>最无聊的概念时间：</p><p>动态库就是：<code>windows</code>中的<code>.dll</code>文件，<code>linux</code>中的<code>.so</code>文件。</p><p>那么它有什么特点？</p><p>不会把代码编译到二进制文件中，而是在运行时候才会去加载，所以只需要一个地址。</p><p>不会编译成二进制文件？也就是不能反向学习了。</p><p><em><strong>用于生成动态库的编译常用参数：</strong></em></p><ul><li><p><code>-fPIC</code> 产生位置无关的代码。</p></li><li><p><code>-shared</code> 共享。</p></li><li><p><code>-l</code> (小写L)，手动指定动态库。</p></li><li><p><code>-I</code> (大写i)，指定头文件目录，默认当前目录.</p></li><li><p><code>-L</code> 手动指定库文件搜索目录, 默认只链接共享目录。</p></li></ul><p>如何生成一个动态库？</p><p><code>gcc -c [源文件名].c -o [自定义文件名].o</code></p><p><code>gcc -shared -fPIC [待生成文件名].o -o [lib生成文件名].so</code></p><p><strong>必须是<code>.o</code>文件！</strong></p><p><strong>必须是<code>.o</code>文件！！</strong></p><p><strong>必须是<code>.o</code>文件！！！</strong></p><p>这样就好了。</p><p>当然了作为动态库文件，命名时必须以<code>lib</code>开头，自定义但没有完全自定义。</p><p>生成好了，没有报错，怎么用？</p><p>正确的：<code>gcc *.c -lMyAdd -L./ -o main</code></p><p>错误的：<code>gcc -o main main.c -L./ -lMyAdd</code></p><p><strong>注意命令顺序</strong></p><p>还是一个命令解决。</p><p>这样就使用生成的动态库文件编译好了一个程序。</p><p>但是出错了？意料之中，这里有两个简单的解决办法。</p><p>运行时手动指定动态库目录：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">MacOS:</span><br><span class="hljs-function"><span class="hljs-title">DYLD_LIBRARY_PATH</span>=./<span class="hljs-title">src_so</span></span><br><span class="hljs-function"><span class="hljs-title">export</span> <span class="hljs-title">DYLD_LIBRARY_PATH</span></span><br><span class="hljs-function"><span class="hljs-title">Linux</span>:</span><br><span class="hljs-function"><span class="hljs-title">LD_LIBRARY_PATH</span>=./<span class="hljs-title">src_so</span></span><br><span class="hljs-function"><span class="hljs-title">export</span> <span class="hljs-title">DYLD_LIBRARY_PATH</span></span><br></code></pre></td></tr></table></figure><p><code>cp libMyAdd.so /usr/lib/</code>将文件拷贝到<code>/usr/lib/</code>文件夹下。</p><p>还是不行？</p><p>问<a href="https://chat18.aichatos.xyz/#/chat/1706331925787"><code>OpenAI</code></a>吧。</p><p>但是尽量跟用户手册搭配使用哦。</p><h2 id="11-世界是绝对的运动和相对的静止。makefile静态库！-我都懒得提"><a href="#11-世界是绝对的运动和相对的静止。makefile静态库！-我都懒得提" class="headerlink" title="11. 世界是绝对的运动和相对的静止。makefile静态库！(我都懒得提)"></a>11. 世界是绝对的运动和相对的静止。makefile静态库！(我都懒得提)</h2><p>静态链接库：会把静态库的代码编译到二进制中，当程序编译完成后，该文件可以删除。</p><p>缺点： 程序体积过大，并且库中的内容如果有更新，则需要重新编译生成程序。</p><p>只有缺点？</p><p>是的，只有缺点。</p><p>所以，别用了。</p><p>你问我玩意用到了？</p><p><a href="https://chat18.aichatos.xyz/#/chat/1706331925787"><code>OpenAI</code></a>吧，别烦了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
