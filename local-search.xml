<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Makefile基础</title>
    <link href="/2024/01/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/01/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="makefile基础"><a href="#makefile基础" class="headerlink" title="makefile基础"></a>makefile基础</h1><h2 id="0-C语言文件编译流程。你必须明白！"><a href="#0-C语言文件编译流程。你必须明白！" class="headerlink" title="0. C语言文件编译流程。你必须明白！"></a>0. C语言文件编译流程。你必须明白！</h2><p>预编译-&gt;编译-&gt;汇编-&gt;链接</p><ol><li><p>预编译所做的事情：</p><p>C++文件：<code>gcc -E [文件名.cpp] &gt; [预处理文件名.ii]</code>：生成<code>.ii</code>文件</p><p>C语言文件：<code>gcc -E [文件名.c] &gt; [预处理文件名.i]</code>：生成<code>.i</code>文件</p><ul><li>展开头文件 ：<code>#include &lt;stdio.h&gt;</code></li><li>宏替换</li><li>去掉代码中的注释</li><li>条件编译</li></ul></li><li><p>编译</p><p><code>gcc -E [预处理文件名.i]</code>：生成<code>.s</code>文件(汇编文件)</p></li><li><p>汇编</p><p><code>gcc -c [编译文件名.s]</code>：生成<code>.o</code>文件</p></li><li><p>链接</p><p><code>gcc [汇编文件名.o]</code>：生成<code>.exe</code>文件</p></li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 示例代码<br>gcc -E main.c &gt; main.i<br>gcc -S main.i<br>gcc -c main.s<br>gcc main.o<br></code></pre></td></tr></table></figure><p><img src="/assets/image-20240127213443580.png" alt="image-20240127213443580"></p><img src="/2024/01/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/image-20240127213443580.png" class=""><hr><h2 id="2-一个make解决所有"><a href="#2-一个make解决所有" class="headerlink" title="2. 一个make解决所有"></a>2. 一个make解决所有</h2><p>在工作目录下有多个文件需要编译时，需要大量的编译时间。</p><p>使用makefile编译程序，makefile只会编译工作目录中改动的部分代码。</p><p>这也是使用makefile编译程序的核心目的。</p><p><strong>用makefile节省你的工作时间。</strong></p><ul><li>如果target是最新生成的，那么make不会执行makefile文件中的任何命令；</li><li>如果target不存在或者target不是最新的，那么make会执行makefile文件中生成target所关联的命令，并根据需要递归地执行生成其他依赖文件的命令；</li><li>如果target关联的某些源代码文件被修改，或者target的某些依赖文件缺失，那么make会执行命令生成最新的依赖文件，并执行makefile文件中生成target所关联的命令。</li></ul><p><img src="/assets/image-20240127135051921.png" alt="image-20240127135051921"></p><hr><h2 id="3-man-man-man-makefile！学会怎么使用makefile。"><a href="#3-man-man-man-makefile！学会怎么使用makefile。" class="headerlink" title="3. man man man makefile！学会怎么使用makefile。"></a>3. <strong>man man man makefile！</strong>学会怎么使用makefile。</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">make [选项] [目标] # 执行选定目标(target)命令<br>make # 默认执行第一个makefile命令<br></code></pre></td></tr></table></figure><p>一个makefile文件中包含多个makefile命令。</p><p>一个完整的makefile命令包含：</p><ol><li>目标：<strong>target</strong></li><li>依赖：<strong>dependence</strong></li><li>命令：<strong>command</strong></li></ol><p>一个正确的makefile的基本格式：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">target:dependences1 dependences2……</span><br>&lt;tab&gt;commands1 commands2……<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>command列表中的每一个<strong>命令</strong>用<code>一个空格</code>隔开</li><li>dependence列表中的每一个<strong>依赖</strong>用<code>一个空格</code>隔开</li><li>其余任何地方不能出现空格</li><li>makefile文件中的注释用<code>#</code></li></ul><p><img src="/assets/image-20240127224100507.png" alt="image-20240127224100507"></p><hr><h2 id="4-用makefile命名你的makefile！禁止套娃！makefile编译过程。"><a href="#4-用makefile命名你的makefile！禁止套娃！makefile编译过程。" class="headerlink" title="4. 用makefile命名你的makefile！禁止套娃！makefile编译过程。"></a>4. 用makefile命名你的makefile！禁止套娃！makefile编译过程。</h2><p><img src="/assets/v2-545a34b80f7822a51d87d62d703d1607_720w.webp" alt="img"></p><p>当文件中同时存在<code>makefile</code>文件与<code>Makefile</code>文件时</p><ul><li>使用<code>make</code>命令会优先执行<code>makefile</code>文件。当没有找到<code>makefile</code>文件时，会转而寻找洽谈文件。</li><li>如果想要执行<code>Makefile</code>文件，需要使用<code>make -f Makefile</code>。</li></ul><p><strong>如果我写了很多个makefile文件，天知道我应该执行哪个！所以，只写一个叫makefile的makefile吧</strong></p><hr><h2 id="5-makefile选项，选择适合你的方式。"><a href="#5-makefile选项，选择适合你的方式。" class="headerlink" title="5. makefile选项，选择适合你的方式。"></a>5. makefile选项，选择适合你的方式。</h2><ul><li><code>-f</code> 选择<code>makefile</code>文件作为<code>make</code>命令的输入文件。</li><li><code>-B</code> 无条件执行所有目标。</li><li><code>-n</code> 只打印命令不执行命令。</li></ul><hr><h2 id="6-ERROR！是makefile的问题？不，是你的问题！"><a href="#6-ERROR！是makefile的问题？不，是你的问题！" class="headerlink" title="6. ERROR！是makefile的问题？不，是你的问题！"></a>6. ERROR！是makefile的问题？不，是你的问题！</h2><ul><li>依赖和目标拼写错误。</li><li><tab>写成了空格。</li><li>重复编译同一目标。</li><li>也许是其他文件的问题。</li></ul><hr><h2 id="7-写一个makefile吧！"><a href="#7-写一个makefile吧！" class="headerlink" title="7. 写一个makefile吧！"></a>7. 写一个makefile吧！</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">main:main.o myAdd.o myDiv.o myMinus.o myMulti.o</span><br>gcc main.o myAdd.o myDiv.o myMinus.o myMulti.o -o main<br><br><span class="hljs-section">myAdd.o:myAdd.c</span><br>gcc -c myAdd.c -o myAdd.o<br><br><span class="hljs-section">myMinus.o:myMinus.c</span><br>gcc -c myMinus.c -o myMinus.o<br><br><span class="hljs-section">myMulti.o:myMulti.c</span><br>gcc -c myMulti.c -o myMulti.o<br><br><span class="hljs-section">myDiv.o:myDiv.c</span><br>gcc -c myDiv.c -o myDiv.o<br><br><span class="hljs-section">main.o:main.c</span><br>gcc -c main.c -o main.o<br><br><span class="hljs-section">clean:</span><br>@rm -rf *.o main<br></code></pre></td></tr></table></figure><p>首先，你得有这些：</p><p><img src="/assets/image-20240127225643538.png" alt="image-20240127225643538"></p><p>把上面的代码复制到makefile里面吧。</p><p><strong>然后？make！</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">make<br></code></pre></td></tr></table></figure><p>接下来会发生什么呢？</p><p>首先。</p><p>之前说过，一个<code>make</code>命令会优先找文件夹下有没有<code>makefile</code>文件。</p><p>结果就是，找到了。</p><p>可是你没有告诉<code>make</code>它的执行<code>目标(target)</code>。</p><p>那么它会默认将第一个<code>target</code>作为它的生成目标。</p><p>Oh！你的<code>target</code>叫<code>main</code>，你的最终目标是一个叫<code>main</code>的可执行文件。</p><p>那么要用到那些文件来达成你这个目标呢？</p><p><code>main.o</code> <code>myAdd.o</code> <code>myDiv.o</code> <code>myMinus.o</code> <code>myMulti.o</code> </p><p>上面的就是你的<code>dependence</code>列表了。</p><p>也就是生成你的<code>目标(target)</code>需要用到的<code>依赖(dependence)</code>。</p><p>注意到它们之间有空格，这是必须的。</p><p>接下来，编译？递归？或者说栈？</p><p><code>make</code>会根据你的<code>makefile文件</code>中描述的<code>依赖(dependence)</code>关系来生成你的<code>目标(target)</code>。</p><p>如果<code>目标(target)</code>的依赖下面还有依赖怎么办？</p><p>那当然是一层层套娃，其实就是一个自下而上的<code>递归</code>，直到所有的<code>依赖(dependence)</code>都被满足了。</p><p>这个目标才会被编译，而编译的过程就是递归调用一层一层<code>return</code>的过程。</p><p>最终，你的目标(target)实现了！</p><p>看看吧选择你的文件夹下多了一个<code>main</code>文件。</p><p>执行它，就是你想要的结果。</p><p>担心程序有bug？</p><p>那你最好使用<code>-g</code>的编译语句来书写你的makefile。</p><hr><h2 id="8-全是字母？别担心，用变量吧。"><a href="#8-全是字母？别担心，用变量吧。" class="headerlink" title="8. 全是字母？别担心，用变量吧。"></a>8. 全是字母？别担心，用变量吧。</h2><ol><li><p>系统变量</p><ul><li><p><code>$@</code>：表示目标文件的完整名称。</p></li><li><p><code>$^</code>：表示所有不重复的依赖文件</p></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 用$@替换上述代码中的目标文件，即[target]</span><br><span class="hljs-comment"># 用$……替换上述代码中的依赖文件，即[dependence]</span><br><span class="hljs-section">main:main.o myAdd.o myDiv.o myMinus.o myMulti.o</span><br>gcc <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myAdd.o:myAdd.c</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myMinus.o:myMinus.c</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myMulti.o:myMulti.c</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myDiv.o:myDiv.c</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">main.o:main.c</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">clean:</span><br>@rm -rf *.o main<br></code></pre></td></tr></table></figure></li><li><p>系统常量</p><ul><li><p><code>RM</code>：删除</p></li><li><p><code>CC</code>：C语言编译程序</p></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 用$(CC)替换上述代码中的gcc编译命令</span><br><span class="hljs-section">main:main.o myAdd.o myDiv.o myMinus.o myMulti.o</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myAdd.o:myAdd.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myMinus.o:myMinus.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myMulti.o:myMulti.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myDiv.o:myDiv.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">main.o:main.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">clean:</span><br>@<span class="hljs-variable">$(RM)</span> *.o main<br></code></pre></td></tr></table></figure></li><li><p>自定义变量</p><ul><li>使用<code>[常量名]=[值]</code>的形式定义自定义常量</li><li>使用<code>$()</code>取自定义变量的值</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OBJS=main.o myAdd.o myDiv.o myMinus.o myMulti.o<br><span class="hljs-comment"># 变量自定义赋值</span><br>TARGET=main<br><br><span class="hljs-comment"># 变量取值用$()</span><br><span class="hljs-variable">$(TARGET)</span>:<span class="hljs-variable">$(OBJS)</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myAdd.o:myAdd.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myMinus.o:myMinus.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myMulti.o:myMulti.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">myDiv.o:myDiv.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">main.o:main.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">clean:</span><br>@<span class="hljs-variable">$(RM)</span> *.o main<br></code></pre></td></tr></table></figure><p>这只是一些简单的变量，其他的等待后续补充吧。</p><p>是不是简单了很多？别担心，还会更简单的！</p></li></ol><hr><h2 id="9-还是有太多冗余了，也许我该考虑更好的方法。模式匹配是个不错的选择。"><a href="#9-还是有太多冗余了，也许我该考虑更好的方法。模式匹配是个不错的选择。" class="headerlink" title="9. 还是有太多冗余了，也许我该考虑更好的方法。模式匹配是个不错的选择。"></a>9. 还是有太多冗余了，也许我该考虑更好的方法。模式匹配是个不错的选择。</h2><p>一些简单的简单的<code>makefile模式匹配</code></p><ul><li><p><code>%[目标]:%[依赖]</code>：我想不用我解释了。</p></li><li><p><code>wildcard</code>：匹配文件。</p></li></ul><p>​使用实例：获取指定目录下所有的.c文件。</p><ul><li><code>patsubst</code>：模式匹配与替换。</li></ul><p>​使用实例：指定目录下所有的.c文件替换成.o文件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 使用文件匹配替换依赖[dependence]</span><br>OBJS=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, $(<span class="hljs-built_in">wildcard</span> ./*.c)</span>)<br><span class="hljs-comment"># 变量自定义赋值</span><br>TARGET=main<br><br><span class="hljs-comment"># 变量取值用$()</span><br><span class="hljs-variable">$(TARGET)</span>:<span class="hljs-variable">$(OBJS)</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-comment"># 模式匹配 %[目标]:%[依赖]</span><br><span class="hljs-section">%.o:%.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-comment"># 伪目标(伪文件)，指执行命令，不生成文件</span><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><br><span class="hljs-section">clean:</span><br>@<span class="hljs-variable">$(RM)</span> *.o main<br><br><span class="hljs-comment"># `wildcard`：匹配文件 ()</span><br><span class="hljs-comment"># `patsubst`：模式匹配与替换</span><br><span class="hljs-section">show:</span><br>@echo <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.c)</span><br>@echo <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, $(<span class="hljs-built_in">wildcard</span> ./*.c)</span>)<br></code></pre></td></tr></table></figure><p><code>tip</code>：有个小概念，什么是伪目标？或者该叫他伪文件。</p><p>所有的目标(target)最终都会生成一个同名的目标文件。</p><p>也许有时候我不希望它生成。</p><p>这个时候就可以用<code>.PHONY: clean</code>来修饰这个<code>目标(target)</code>。</p><p>当需要生成这个<code>目标(target)</code>时，不会生成文件，而只是执行命令。</p><hr><h2 id="10-Triple-Star！最重要的一集。makefile动态库。"><a href="#10-Triple-Star！最重要的一集。makefile动态库。" class="headerlink" title="10. Triple Star！最重要的一集。makefile动态库。"></a>10. Triple Star！最重要的一集。makefile动态库。</h2><p>最无聊的概念时间：</p><p>动态库就是：<code>windows</code>中的<code>.dll</code>文件，<code>linux</code>中的<code>.so</code>文件。</p><p>那么它有什么特点？</p><p>不会把代码编译到二进制文件中，而是在运行时候才会去加载，所以只需要一个地址。</p><p>不会编译成二进制文件？也就是不能反向学习了。</p><p><em><strong>用于生成动态库的编译常用参数：</strong></em></p><ul><li><p><code>-fPIC</code> 产生位置无关的代码。</p></li><li><p><code>-shared</code> 共享。</p></li><li><p><code>-l</code> (小写L)，手动指定动态库。</p></li><li><p><code>-I</code> (大写i)，指定头文件目录，默认当前目录.</p></li><li><p><code>-L</code> 手动指定库文件搜索目录, 默认只链接共享目录。</p></li></ul><p>如何生成一个动态库？</p><p><code>gcc -c [源文件名].c -o [自定义文件名].o</code></p><p><code>gcc -shared -fPIC [待生成文件名].o -o [lib生成文件名].so</code></p><p><strong>必须是<code>.o</code>文件！</strong></p><p><strong>必须是<code>.o</code>文件！！</strong></p><p><strong>必须是<code>.o</code>文件！！！</strong></p><p>这样就好了。</p><p>当然了作为动态库文件，命名时必须以<code>lib</code>开头，自定义但没有完全自定义。</p><p>生成好了，没有报错，怎么用？</p><p>正确的：<code>gcc *.c -lMyAdd -L./ -o main</code></p><p>错误的：<code>gcc -o main main.c -L./ -lMyAdd</code></p><p><strong>注意命令顺序</strong></p><p>还是一个命令解决。</p><p>这样就使用生成的动态库文件编译好了一个程序。</p><p>但是出错了？意料之中，这里有两个简单的解决办法。</p><p>运行时手动指定动态库目录：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">MacOS:</span><br><span class="hljs-function"><span class="hljs-title">DYLD_LIBRARY_PATH</span>=./<span class="hljs-title">src_so</span></span><br><span class="hljs-function"><span class="hljs-title">export</span> <span class="hljs-title">DYLD_LIBRARY_PATH</span></span><br><span class="hljs-function"><span class="hljs-title">Linux</span>:</span><br><span class="hljs-function"><span class="hljs-title">LD_LIBRARY_PATH</span>=./<span class="hljs-title">src_so</span></span><br><span class="hljs-function"><span class="hljs-title">export</span> <span class="hljs-title">DYLD_LIBRARY_PATH</span></span><br></code></pre></td></tr></table></figure><p><code>cp libMyAdd.so /usr/lib/</code>将文件拷贝到<code>/usr/lib/</code>文件夹下。</p><p>还是不行？</p><p>问<a href="https://chat18.aichatos.xyz/#/chat/1706331925787"><code>OpenAI</code></a>吧。</p><p>但是尽量跟用户手册搭配使用哦。</p><h2 id="11-世界是绝对的运动和相对的静止。makefile静态库！-我都懒得提"><a href="#11-世界是绝对的运动和相对的静止。makefile静态库！-我都懒得提" class="headerlink" title="11. 世界是绝对的运动和相对的静止。makefile静态库！(我都懒得提)"></a>11. 世界是绝对的运动和相对的静止。makefile静态库！(我都懒得提)</h2><p>静态链接库：会把静态库的代码编译到二进制中，当程序编译完成后，该文件可以删除。</p><p>缺点： 程序体积过大，并且库中的内容如果有更新，则需要重新编译生成程序。</p><p>只有缺点？</p><p>是的，只有缺点。</p><p>所以，别用了。</p><p>你问我玩意用到了？</p><p><a href="https://chat18.aichatos.xyz/#/chat/1706331925787"><code>OpenAI</code></a>吧，别烦了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/01/17/hello-world/"/>
    <url>/2024/01/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
